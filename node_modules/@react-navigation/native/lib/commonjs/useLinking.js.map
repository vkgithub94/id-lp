{"version":3,"sources":["useLinking.tsx"],"names":["getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","prefixes","config","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","React","useEffect","Error","prefixesRef","useRef","configRef","getStateFromPathRef","getPathFromStateRef","current","getInitialState","useCallback","path","location","pathname","search","undefined","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","window","addEventListener","navigation","previousHistoryIndex","historyIndex","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","type","resetRoot","payload","dispatch","unsubscribe","addListener","previousStateLength","stateLength","l","pushState","delta","go"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    prefixes,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (isUsingLinking) {\n      throw new Error(\n        \"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts.\"\n      );\n    } else {\n      isUsingLinking = true;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const prefixesRef = React.useRef(prefixes);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    prefixesRef.current = prefixes;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, getPathFromState, getStateFromPath, prefixes]);\n\n  const getInitialState = React.useCallback(() => {\n    const path = location.pathname + location.search;\n\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    window.addEventListener('popstate', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action.type === 'RESET_ROOT') {\n            navigation.resetRoot(action.payload);\n          } else {\n            navigation.dispatch(action);\n          }\n        }\n      }\n    });\n  }, [ref]);\n\n  React.useEffect(() => {\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new enrties were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new enrties were added, pushState until we have same length\n        // This won't be accurate if multiple enrties were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = previousStateLength - stateLength;\n\n        // We need to set this to ignore the `popstate` event\n        pendingIndexChangeRef.current = index - delta;\n\n        // If new enrties were removed, go back so that we have same length\n        history.go(-delta);\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]}