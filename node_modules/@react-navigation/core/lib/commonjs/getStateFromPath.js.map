{"version":3,"sources":["getStateFromPath.tsx"],"names":["getStateFromPath","path","options","undefined","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","result","current","remaining","replace","routeNames","params","config","match","paramPatterns","pattern","split","filter","p","startsWith","length","reduce","acc","i","value","parse","segments","decodeURIComponent","shift","join","state","routeName","initialRoute","findInitialRoute","createNestedState","nestedState","routes","index","query","route","queryString","parseFunction","findParseConfigForRoute","name","forEach","routeConfig","initials","push","createConfigItem","screens","initialRouteName","connectedRoutes","nestedConfig","pop","RegExp","flatConfig","includes","isEmpty"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport { NavigationState, PartialState, InitialState } from './types';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  if (path === '') {\n    return undefined;\n  }\n  let initialRoutes: InitialRouteConfig[] = [];\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map(key =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter(p => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n    let routeName = routeNames.shift() as string;\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n    state = createNestedState(\n      initialRoute,\n      routeName,\n      routeNames.length === 0,\n      params\n    );\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while ((routeName = routeNames.shift() as string)) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\n          initialRoute,\n          routeName,\n          routeNames.length === 0,\n          params\n        );\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0]\n            .state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current?.routes[current.index || 0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = (current as PartialState<NavigationState>).routes[\n      current?.index || 0\n    ];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach(name => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach(nestedConfig => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createNestedState(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n"]}