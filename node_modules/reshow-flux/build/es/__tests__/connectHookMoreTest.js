import _assertThisInitialized from "reshow-runtime/es/helpers/assertThisInitialized";
import _defineProperty from "reshow-runtime/es/helpers/defineProperty";
import _objectSpread from "reshow-runtime/es/helpers/objectSpread2";
import _classCallCheck from "reshow-runtime/es/helpers/classCallCheck";
import _createClass from "reshow-runtime/es/helpers/createClass";
import _possibleConstructorReturn from "reshow-runtime/es/helpers/possibleConstructorReturn";
import _getPrototypeOf from "reshow-runtime/es/helpers/getPrototypeOf";
import _inherits from "reshow-runtime/es/helpers/inherits";
import React, { Component, StrictMode } from 'react';
import { expect } from 'chai';
import { shallow, mount, configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
configure({
  adapter: new Adapter()
});
import connectHook from '../connectHook';
import ReduceStore from '../ReduceStore';
import { Dispatcher } from '../index';
import { CHANGE } from 'reshow-flux-base';
describe('Test Connect hook for more test', function () {
  var FakeStore =
  /*#__PURE__*/
  function (_ReduceStore) {
    _inherits(FakeStore, _ReduceStore);

    function FakeStore() {
      _classCallCheck(this, FakeStore);

      return _possibleConstructorReturn(this, _getPrototypeOf(FakeStore).apply(this, arguments));
    }

    _createClass(FakeStore, [{
      key: "getInitialState",
      value: function getInitialState() {
        return {
          foo: 'bar'
        };
      }
    }, {
      key: "reduce",
      value: function reduce(state, action) {
        return action;
      }
    }]);

    return FakeStore;
  }(ReduceStore);

  var dispatcher;
  var store;
  beforeEach(function () {
    dispatcher = new Dispatcher();
    store = new FakeStore(dispatcher);
  });
  it('could register with store', function () {
    var FakeComponent = function FakeComponent(_ref) {
      var foo = _ref.foo;
      return React.createElement("div", null, foo);
    };

    var FakeConnected = connectHook(FakeComponent, {
      calculateState: function calculateState(prevState, props) {
        if (!prevState.__init__) {
          return {
            __init__: true
          };
        } else {
          return {
            foo: store.getState().foo
          };
        }
      },
      getStores: function getStores(props) {
        return [store];
      }
    });
    var vDom = React.createElement(FakeConnected, null);
    var wrap = mount(vDom);
    store.emit(CHANGE);
    expect(wrap.html()).to.equal('<div>bar</div>');
  });
  it('could work with dispatcher', function () {
    var calculateTimes = 0;

    var FakeComponent = function FakeComponent(_ref2) {
      var aaa = _ref2.aaa;
      return React.createElement("div", null, aaa);
    };

    var FakeConnected = connectHook(FakeComponent, {
      calculateState: function calculateState(prevState, props) {
        var state = store.getState();
        calculateTimes++;
        return {
          aaa: state.aaa
        };
      },
      getStores: function getStores(props) {
        return [store];
      }
    });
    expect(calculateTimes).to.equal(0);
    var vDom = React.createElement(FakeConnected, null);
    expect(calculateTimes).to.equal(0);
    var html = mount(vDom);
    expect(calculateTimes).to.equal(2); //init and handlchange

    dispatcher.dispatch({
      aaa: 'Hello dispatcher!'
    });
    html.update();
    expect(calculateTimes).to.equal(3);
    expect(html.html()).to.equal('<div>Hello dispatcher!</div>');
    html.unmount();
    dispatcher.dispatch({
      aaa: 'Hello Unmount!'
    });
    expect(calculateTimes).to.equal(3);
  });
  it('could work withProps', function (done) {
    var getStoresProps = null;
    var calculateStateProps = null;

    var FakeComponent = function FakeComponent(_ref3) {
      var foo = _ref3.foo;
      return React.createElement("div", null, foo);
    };

    var FakeConnected = connectHook(FakeComponent, {
      calculateState: function calculateState(prevState, props) {
        calculateStateProps = _objectSpread({}, props);
        return {
          foo: props.foo
        };
      },
      getStores: function getStores(props) {
        getStoresProps = props;
        return [store];
      }
    });
    var changeFoo;

    var Parent =
    /*#__PURE__*/
    function (_Component) {
      _inherits(Parent, _Component);

      function Parent(props) {
        var _this;

        _classCallCheck(this, Parent);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Parent).call(this, props));

        _defineProperty(_assertThisInitialized(_this), "state", {});

        changeFoo = function changeFoo(v) {
          _this.setState({
            foo: v
          });
        };

        return _this;
      }

      _createClass(Parent, [{
        key: "render",
        value: function render() {
          var foo = null;

          if (this.state && this.state.foo) {
            foo = this.state.foo;
          }

          return React.createElement(FakeConnected, {
            foo: foo
          });
        }
      }]);

      return Parent;
    }(Component);

    var vDom = React.createElement(Parent, null);
    var wrap = mount(vDom);
    expect(getStoresProps).to.deep.equal({
      foo: null
    });
    expect(calculateStateProps).to.deep.equal({
      foo: null
    });
    changeFoo('bar');
    wrap.update();
    setTimeout(function () {
      expect(wrap.html()).to.equal('<div>bar</div>');
      expect(getStoresProps).to.deep.equal({
        foo: 'bar'
      });
      expect(calculateStateProps).to.deep.equal({
        foo: 'bar'
      });
      done();
    });
  });
  it('could work with empty calculateState', function () {
    var FakeComponent = function FakeComponent(_ref4) {
      var foo = _ref4.foo;
      return React.createElement("div", null, foo);
    };

    var FakeConnected = connectHook(FakeComponent, {
      calculateState: function calculateState(prevState, props) {},
      getStores: function getStores(props) {
        return [store];
      }
    });
    var vDom = React.createElement(FakeConnected, {
      aaa: "bbb"
    });
    var wrap = mount(vDom);
    var props = wrap.props();
    expect(props).to.deep.equal({
      aaa: 'bbb'
    });
  });
});