{"version":3,"sources":["getPathFromState.tsx"],"names":["getPathFromState","state","options","undefined","Error","path","current","index","route","routes","currentOptions","pattern","name","screens","nextRoute","deeperConfig","config","stringify","params","Object","entries","reduce","acc","key","value","String","split","map","p","replace","startsWith","encodeURIComponent","join","query","queryString","slice","length"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport { NavigationState, PartialState, Route } from './types';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        stringify?: StringifyConfig;\n        screens?: Options;\n      };\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: Options = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n  let path = '/';\n\n  let current: State | undefined = state;\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n    let currentOptions = options;\n    let pattern = route.name;\n\n    while (route.name in currentOptions) {\n      if (typeof currentOptions[route.name] === 'string') {\n        pattern = currentOptions[route.name] as string;\n        break;\n      } else if (typeof currentOptions[route.name] === 'object') {\n        // if there is no `screens` property, we return pattern\n        if (\n          !(currentOptions[route.name] as {\n            screens: Options;\n          }).screens\n        ) {\n          pattern = (currentOptions[route.name] as { path: string }).path;\n          break;\n        } else {\n          // if it is the end of state, we return pattern\n          if (route.state === undefined) {\n            pattern = (currentOptions[route.name] as { path: string }).path;\n            break;\n          } else {\n            index =\n              typeof route.state.index === 'number' ? route.state.index : 0;\n            const nextRoute = route.state.routes[index];\n            const deeperConfig = (currentOptions[route.name] as {\n              screens: Options;\n            }).screens;\n            // if there is config for next route name, we go deeper\n            if (nextRoute.name in deeperConfig) {\n              route = nextRoute as Route<string> & { state?: State };\n              currentOptions = deeperConfig;\n            } else {\n              // if not, there is no sense in going deeper in config\n              pattern = (currentOptions[route.name] as { path: string }).path;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // we don't add empty path strings to path\n    if (pattern !== '') {\n      const config =\n        currentOptions[route.name] !== undefined\n          ? (currentOptions[route.name] as { stringify?: StringifyConfig })\n              .stringify\n          : undefined;\n\n      const params = route.params\n        ? // Stringify all of the param values before we use them\n          Object.entries(route.params).reduce<{\n            [key: string]: string;\n          }>((acc, [key, value]) => {\n            acc[key] = config?.[key] ? config[key](value) : String(value);\n            return acc;\n          }, {})\n        : undefined;\n\n      if (currentOptions[route.name] !== undefined) {\n        path += pattern\n          .split('/')\n          .map(p => {\n            const name = p.replace(/^:/, '');\n\n            // If the path has a pattern for a param, put the param in the path\n            if (params && name in params && p.startsWith(':')) {\n              const value = params[name];\n              // Remove the used value from the params object since we'll use the rest for query string\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete params[name];\n              return encodeURIComponent(value);\n            }\n\n            return encodeURIComponent(p);\n          })\n          .join('/');\n      } else {\n        path += encodeURIComponent(route.name);\n      }\n\n      if (route.state) {\n        path += '/';\n      } else if (params) {\n        const query = queryString.stringify(params);\n\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n    }\n\n    current = route.state;\n  }\n\n  path = path.slice(path.length - 1) === '/' ? path.slice(0, -1) : path;\n  return path;\n}\n"]}