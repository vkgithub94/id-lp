{"version":3,"sources":["useLinking.native.tsx"],"names":["React","Linking","getActionFromState","getStateFromPath","getStateFromPathDefault","isUsingLinking","useLinking","ref","prefixes","config","useEffect","Error","prefixesRef","useRef","configRef","getStateFromPathRef","current","extractPathFromURL","useCallback","url","prefix","startsWith","replace","undefined","getInitialState","getInitialURL","path","listener","navigation","state","action","type","resetRoot","payload","dispatch","addEventListener","removeEventListener"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Linking } from 'react-native';\nimport {\n  getActionFromState,\n  getStateFromPath as getStateFromPathDefault,\n  NavigationContainerRef,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    prefixes,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (isUsingLinking) {\n      throw new Error(\n        \"Looks like you are using 'useLinking' in multiple components. This is likely an error since deep links should only be handled in one place to avoid conflicts.\"\n      );\n    } else {\n      isUsingLinking = true;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const prefixesRef = React.useRef(prefixes);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n\n  React.useEffect(() => {\n    prefixesRef.current = prefixes;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n  }, [config, getStateFromPath, prefixes]);\n\n  const extractPathFromURL = React.useCallback((url: string) => {\n    for (const prefix of prefixesRef.current) {\n      if (url.startsWith(prefix)) {\n        return url.replace(prefix, '');\n      }\n    }\n\n    return undefined;\n  }, []);\n\n  const getInitialState = React.useCallback(async () => {\n    const url = await Linking.getInitialURL();\n    const path = url ? extractPathFromURL(url) : null;\n\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }, [extractPathFromURL]);\n\n  React.useEffect(() => {\n    const listener = ({ url }: { url: string }) => {\n      const path = extractPathFromURL(url);\n      const navigation = ref.current;\n\n      if (navigation && path) {\n        const state = getStateFromPathRef.current(path, configRef.current);\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          if (action.type === 'RESET_ROOT') {\n            navigation.resetRoot(action.payload);\n          } else {\n            navigation.dispatch(action);\n          }\n        }\n      }\n    };\n\n    Linking.addEventListener('url', listener);\n\n    return () => Linking.removeEventListener('url', listener);\n  }, [extractPathFromURL, ref]);\n\n  return {\n    getInitialState,\n  };\n}\n"]}